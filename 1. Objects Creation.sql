set nocount on
set xact_abort on

declare @NewSchemaName sysname
declare @OldSchemaName sysname

declare @TableName varchar(512) , @pk_name varchar(100)
declare @Time varchar(22) 

declare @Table_changes varchar(512) --= '[temp_upg_new].['+@TableName+'_changes]'
declare @TableName_new varchar(512) --= '[temp_upg_new].' + @TableName
declare @TableName_old varchar(512) --= '[temp_upg_old].' + @TableName

declare	@TriggetName varchar(512) --= 'trg_'+@TableName+'_keep_updates'
declare @SQL varchar(max)

------------	=============== I N P U T   S E C T I O N ============= ------------

 -- by T-SQL
SET @TableName = 'heavy_updates' 
SET @NewSchemaName = 'temp_upg_new'
SET @OldSchemaName = 'temp_upg_old'

-- -- by SQLCMD 
--SET @TableName = '$(tablename)'
--SET @NewSchemaName = '$(NewSchemaName)'
--SET @OldSchemaName = '$(OldSchemaName)'

------------	======================================================= ------------

SET @Table_changes = '[' + @NewSchemaName + '].['+@TableName+'_changes]'
SET @TableName_new = '[' + @NewSchemaName + '].[' + @TableName + ']'
SET @TableName_old = '[' + @OldSchemaName + '].[' + @TableName + ']' -- exists if Darwin process already was running before on that table
SET @TriggetName = 'trg_'+@TableName+'_keep_updates'

-- Sorry... Table must have PK
SELECT @pk_name = name FROM sys.key_constraints
WHERE parent_object_id = OBJECT_ID(@TableName) and type = 'PK'

IF @pk_name IS NULL 
BEGIN
	RAISERROR('%s		Sorry, Table %s must have PK',10, 1, @Time, @TableName)
	RETURN
END

-- Prepare list of PK columns
DECLARE @Table_PK_Columns_compare varchar(1024), @Table_PK_Columns varchar(1024) 
SET @Table_PK_Columns_compare = 'ON '
SET @Table_PK_Columns = ''
SELECT	@Table_PK_Columns_compare = @Table_PK_Columns_compare + 'T1.' + COLUMN_NAME + ' = T2.' + COLUMN_NAME + CHAR(10)
		, @Table_PK_Columns = @Table_PK_Columns + ', ' + COLUMN_NAME
FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
WHERE TABLE_NAME = @TableName and TABLE_SCHEMA = 'dbo' and CONSTRAINT_NAME = @pk_name
SET @Table_PK_Columns = right(@Table_PK_Columns, LEN(@Table_PK_Columns) - 2)


set @Time = convert(Datetime,getdate(),120)
-- Create new schema and staging table that holds keys of modified records
if not exists (select * from sys.schemas where name = @NewSchemaName)
BEGIN
	RAISERROR('%s		Creating schema %s',10, 1, @Time,@NewSchemaName)
	EXEC ('create schema ' + @NewSchemaName)
END

-- Create the old schema for production tables after the "switch"
set @Time = convert(Datetime,getdate(),120)
if not exists (select * from sys.schemas where name = @OldSchemaName)
BEGIN
	RAISERROR('%s		Creating schema %s',10, 1, @Time, @OldSchemaName)
	EXEC ('create schema ' + @OldSchemaName)
END


-- Clean tables from previous synch
IF OBJECT_ID(@Table_changes) IS NOT NULL
BEGIN
	SET @SQL = 'DROP TABLE ' + @Table_changes 
	EXEC (@SQL)
END

IF OBJECT_ID(@TableName_new) IS NOT NULL AND OBJECT_ID(@TableName) IS NOT NULL 
BEGIN
	SET @Time = convert(Datetime,getdate(),120)
	RAISERROR('%s		Drop new table %s',10, 1, @Time, @TableName_new)

	SET @SQL = 'DROP TABLE ' + @TableName_new 
	EXEC (@SQL)
END

set @Time = convert(Datetime,getdate(),120)
RAISERROR('%s		Creating changes table %s',10, 1, @Time, @Table_changes)

-- create "changes" table first step with primary keys
-- (#dummytable is created just to have a "dummy" join to changes table. This is a trik to ignore identity columns in case they exists)

SET @SQL = '
CREATE TABLE #dummytable (dummytable_dummycolumn_notinuse int)

SELECT ' + @Table_PK_Columns + ' 
INTO ' + @Table_changes+ ' 
FROM ' + @TableName + ' 
CROSS JOIN #dummytable WHERE 1=0'
EXEC (@SQL)

-- add "changes" table columns for later use to sync
SET @SQL = '
ALTER TABLE ' + @Table_changes + ' ADD 
	[modified_time] datetime NOT NULL default getdate(),
	[sync_time] datetime NULL,
	[Action_flg] char(1) NOT NULL
	'
EXEC(@SQL)

SET @SQL = '
-- Clustered index of change table definition
	CREATE CLUSTERED INDEX [IX_'+@TableName+'_changes] ON ' + @Table_changes + '
	(modified_time, ' + @Table_PK_Columns + ')'
EXEC(@SQL)

SET @SQL = 'CREATE INDEX idx_' + @NewSchemaName + '_'+@TableName+'_changes_sync_time on '+@Table_changes+' (sync_time)'
EXEC (@SQL)

---------------------------------------------------------------------------------------------------

set @Time = convert(Datetime,getdate(),120)
RAISERROR('%s		Creating trigger on %s',10, 1, @Time, @TableName)
-- Create trigger on source table to save all changes
SET @SQL = 
	'IF OBJECT_ID(''dbo.trg_' + @TableName + '_keep_updates'') IS NOT NULL
		DROP TRIGGER dbo.trg_' + @TableName + '_keep_updates
	'
EXEC(@SQL)

SET @SQL = '
/*

			Jun-2019

			This trigger is auto generated by Darwin process and needed to sync data between production table and newly upgraded table
				Please do not change code or drop this trigger at any circumstance
				for any questions, please ask Chnage Healthcare Cardiology DBAs		

*/
CREATE TRIGGER dbo.trg_'+@TableName+'_keep_updates
	ON dbo.['+ @TableName +'] 
	FOR  INSERT, UPDATE, DELETE 
AS

SET NOCOUNT ON

IF EXISTS (SELECT * FROM deleted)
BEGIN
	insert into '+@Table_changes+' (
		' + @Table_PK_Columns + '
		, modified_time
		, sync_time
		, Action_flg
	)
	select 
		d.' + REPLACE(@Table_PK_Columns,', ',', d.') + '
		, getdate()
		, NULL 
		, ''D''
	from deleted d
END

if exists (select * from inserted)
begin 

	insert into '+@Table_changes+' (
		' + @Table_PK_Columns + '
		, modified_time
		, sync_time
		, Action_flg
	)
	select 
		i.' + replace(@Table_PK_Columns,', ',', i.') + '
		, getdate()
		, NULL 
		, ''I''
	from inserted i 

end 

'
EXEC (@SQL)
set @Time = convert(Datetime,getdate(),120)
RAISERROR('%s		Successfully reached end of init-load, table %s',10, 1, @Time, @TableName)

select @@ERROR as invoke_result

